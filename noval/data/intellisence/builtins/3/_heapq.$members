(dp0
Vname
p1
V_heapq
p2
sVis_builtin
p3
I01
sVdoc
p4
VHeap queue algorithm (a.k.a. priority queue).\u000a\u000aHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\u000aall k, counting elements from 0.  For the sake of comparison,\u000anon-existing elements are considered to be infinite.  The interesting\u000aproperty of a heap is that a[0] is always its smallest element.\u000a\u000aUsage:\u000a\u000aheap = []            # creates an empty heap\u000aheappush(heap, item) # pushes a new item on the heap\u000aitem = heappop(heap) # pops the smallest item from the heap\u000aitem = heap[0]       # smallest item on the heap without popping it\u000aheapify(x)           # transforms list into a heap, in-place, in linear time\u000aitem = heapreplace(heap, item) # pops and returns smallest item, and adds\u000a                               # new item; the heap size is unchanged\u000a\u000aOur API differs from textbook heap algorithms as follows:\u000a\u000a- We use 0-based indexing.  This makes the relationship between the\u000a  index for a node and the indexes for its children slightly less\u000a  obvious, but is more suitable since Python uses 0-based indexing.\u000a\u000a- Our heappop() method returns the smallest item, not the largest.\u000a\u000aThese two make it possible to view the heap as a regular Python list\u000awithout surprises: heap[0] is the smallest item, and heap.sort()\u000amaintains the heap invariant!\u000a
p5
sVchilds
p6
(lp7
(dp8
g1
V__about__
p9
sg3
I01
sVtype
p10
L5L
sa(dp11
g1
V__doc__
p12
sg3
I01
sg10
L5L
sa(dp13
g1
V__loader__
p14
sg3
I01
sg10
L3L
sg6
(lp15
(dp16
g1
V__delattr__
p17
sg3
I01
sg10
L5L
sa(dp18
g1
V__dict__
p19
sg3
I01
sg10
L5L
sa(dp20
g1
V__dir__
p21
sg3
I01
sg10
L2L
sg4
V__dir__() -> list\u000adefault dir() implementation
p22
sa(dp23
g1
g12
sg3
I01
sg10
L5L
sa(dp24
g1
V__eq__
p25
sg3
I01
sg10
L5L
sa(dp26
g1
V__format__
p27
sg3
I01
sg10
L2L
sg4
Vdefault object formatter
p28
sa(dp29
g1
V__ge__
p30
sg3
I01
sg10
L5L
sa(dp31
g1
V__getattribute__
p32
sg3
I01
sg10
L5L
sa(dp33
g1
V__gt__
p34
sg3
I01
sg10
L5L
sa(dp35
g1
V__hash__
p36
sg3
I01
sg10
L5L
sa(dp37
g1
V__init__
p38
sg3
I01
sg10
L5L
sa(dp39
g1
V__init_subclass__
p40
sg3
I01
sg10
L2L
sg4
VThis method is called when a class is subclassed.\u000a\u000aThe default implementation does nothing. It may be\u000aoverridden to extend subclasses.\u000a
p41
sa(dp42
g1
V__le__
p43
sg3
I01
sg10
L5L
sa(dp44
g1
V__lt__
p45
sg3
I01
sg10
L5L
sa(dp46
g1
V__module__
p47
sg3
I01
sg10
L5L
sa(dp48
g1
V__ne__
p49
sg3
I01
sg10
L5L
sa(dp50
g1
V__new__
p51
sg3
I01
sg10
L2L
sg4
VCreate and return a new object.  See help(type) for accurate signature.
p52
sa(dp53
g1
V__reduce__
p54
sg3
I01
sg10
L2L
sg4
Vhelper for pickle
p55
sa(dp56
g1
V__reduce_ex__
p57
sg3
I01
sg10
L2L
sg4
Vhelper for pickle
p58
sa(dp59
g1
V__repr__
p60
sg3
I01
sg10
L5L
sa(dp61
g1
V__setattr__
p62
sg3
I01
sg10
L5L
sa(dp63
g1
V__sizeof__
p64
sg3
I01
sg10
L2L
sg4
V__sizeof__() -> int\u000asize of object in memory, in bytes
p65
sa(dp66
g1
V__str__
p67
sg3
I01
sg10
L5L
sa(dp68
g1
V__subclasshook__
p69
sg3
I01
sg10
L2L
sg4
VAbstract classes can override this to customize issubclass().\u000a\u000aThis is invoked early on by abc.ABCMeta.__subclasscheck__().\u000aIt should return True, False or NotImplemented.  If it returns\u000aNotImplemented, the normal algorithm is used.  Otherwise, it\u000aoverrides the normal algorithm (and the outcome is cached).\u000a
p70
sa(dp71
g1
V__weakref__
p72
sg3
I01
sg10
L5L
sa(dp73
g1
Vcreate_module
p74
sg3
I01
sg10
L5L
sa(dp75
g1
Vexec_module
p76
sg3
I01
sg10
L5L
sa(dp77
g1
Vfind_module
p78
sg3
I01
sg10
L5L
sa(dp79
g1
Vfind_spec
p80
sg3
I01
sg10
L5L
sa(dp81
g1
Vget_code
p82
sg3
I01
sg10
L5L
sa(dp83
g1
Vget_source
p84
sg3
I01
sg10
L5L
sa(dp85
g1
Vis_package
p86
sg3
I01
sg10
L5L
sa(dp87
g1
Vload_module
p88
sg3
I01
sg10
L5L
sa(dp89
g1
Vmodule_repr
p90
sg3
I01
sg10
L5L
sasg4
VMeta path import for built-in modules.\u000a\u000a    All methods are either class or static methods to avoid the need to\u000a    instantiate the class.\u000a\u000a    
p91
sa(dp92
g1
V__name__
p93
sg3
I01
sg10
L5L
sa(dp94
g1
V__package__
p95
sg3
I01
sg10
L5L
sa(dp96
g1
V__spec__
p97
sg3
I01
sg10
L5L
sa(dp98
g1
V_heapify_max
p99
sg3
I01
sg10
L2L
sg4
VMaxheap variant of heapify.
p100
sa(dp101
g1
V_heappop_max
p102
sg3
I01
sg10
L2L
sg4
VMaxheap variant of heappop.
p103
sa(dp104
g1
V_heapreplace_max
p105
sg3
I01
sg10
L2L
sg4
VMaxheap variant of heapreplace
p106
sa(dp107
g1
Vheapify
p108
sg3
I01
sg10
L2L
sg4
VTransform list into a heap, in-place, in O(len(heap)) time.
p109
sa(dp110
g1
Vheappop
p111
sg3
I01
sg10
L2L
sg4
VPop the smallest item off the heap, maintaining the heap invariant.
p112
sa(dp113
g1
Vheappush
p114
sg3
I01
sg10
L2L
sg4
Vheappush(heap, item) -> None. Push item onto heap, maintaining the heap invariant.
p115
sa(dp116
g1
Vheappushpop
p117
sg3
I01
sg10
L2L
sg4
Vheappushpop(heap, item) -> value. Push item on the heap, then pop and return the smallest item\u000afrom the heap. The combined action runs more efficiently than\u000aheappush() followed by a separate call to heappop().
p118
sa(dp119
g1
Vheapreplace
p120
sg3
I01
sg10
L2L
sg4
Vheapreplace(heap, item) -> value. Pop and return the current smallest value, and add the new item.\u000a\u000aThis is more efficient than heappop() followed by heappush(), and can be\u000amore appropriate when using a fixed-size heap.  Note that the value\u000areturned may be larger than item!  That constrains reasonable uses of\u000athis routine unless written as part of a conditional replacement:\u000a\u000a    if item > heap[0]:\u000a        item = heapreplace(heap, item)\u000a
p121
sasg10
L1L
s.