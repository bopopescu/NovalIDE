(dp0
Vchilds
p1
(lp2
(dp3
Vis_builtin
p4
I01
sVname
p5
V__about__
p6
sVtype
p7
L5L
sa(dp8
g4
I01
sg5
V__doc__
p9
sg7
L5L
sa(dp10
g1
(lp11
(dp12
g4
I01
sg5
V__delattr__
p13
sg7
L5L
sa(dp14
g4
I01
sg5
V__dict__
p15
sg7
L5L
sa(dp16
g4
I01
sg5
V__dir__
p17
sg7
L2L
sVdoc
p18
V__dir__() -> list\u000adefault dir() implementation
p19
sa(dp20
g4
I01
sg5
g9
sg7
L5L
sa(dp21
g4
I01
sg5
V__eq__
p22
sg7
L5L
sa(dp23
g4
I01
sg5
V__format__
p24
sg7
L2L
sg18
Vdefault object formatter
p25
sa(dp26
g4
I01
sg5
V__ge__
p27
sg7
L5L
sa(dp28
g4
I01
sg5
V__getattribute__
p29
sg7
L5L
sa(dp30
g4
I01
sg5
V__gt__
p31
sg7
L5L
sa(dp32
g4
I01
sg5
V__hash__
p33
sg7
L5L
sa(dp34
g4
I01
sg5
V__init__
p35
sg7
L5L
sa(dp36
g4
I01
sg5
V__le__
p37
sg7
L5L
sa(dp38
g4
I01
sg5
V__lt__
p39
sg7
L5L
sa(dp40
g4
I01
sg5
V__module__
p41
sg7
L5L
sa(dp42
g4
I01
sg5
V__ne__
p43
sg7
L5L
sa(dp44
g4
I01
sg5
V__new__
p45
sg7
L2L
sg18
VCreate and return a new object.  See help(type) for accurate signature.
p46
sa(dp47
g4
I01
sg5
V__reduce__
p48
sg7
L2L
sg18
Vhelper for pickle
p49
sa(dp50
g4
I01
sg5
V__reduce_ex__
p51
sg7
L2L
sg18
Vhelper for pickle
p52
sa(dp53
g4
I01
sg5
V__repr__
p54
sg7
L5L
sa(dp55
g4
I01
sg5
V__setattr__
p56
sg7
L5L
sa(dp57
g4
I01
sg5
V__sizeof__
p58
sg7
L2L
sg18
V__sizeof__() -> int\u000asize of object in memory, in bytes
p59
sa(dp60
g4
I01
sg5
V__str__
p61
sg7
L5L
sa(dp62
g4
I01
sg5
V__subclasshook__
p63
sg7
L2L
sg18
VAbstract classes can override this to customize issubclass().\u000a\u000aThis is invoked early on by abc.ABCMeta.__subclasscheck__().\u000aIt should return True, False or NotImplemented.  If it returns\u000aNotImplemented, the normal algorithm is used.  Otherwise, it\u000aoverrides the normal algorithm (and the outcome is cached).\u000a
p64
sa(dp65
g4
I01
sg5
V__weakref__
p66
sg7
L5L
sa(dp67
g4
I01
sg5
Vcreate_module
p68
sg7
L5L
sa(dp69
g4
I01
sg5
Vexec_module
p70
sg7
L5L
sa(dp71
g4
I01
sg5
Vfind_module
p72
sg7
L5L
sa(dp73
g4
I01
sg5
Vfind_spec
p74
sg7
L5L
sa(dp75
g4
I01
sg5
Vget_code
p76
sg7
L5L
sa(dp77
g4
I01
sg5
Vget_source
p78
sg7
L5L
sa(dp79
g4
I01
sg5
Vis_package
p80
sg7
L5L
sa(dp81
g4
I01
sg5
Vload_module
p82
sg7
L5L
sa(dp83
g4
I01
sg5
Vmodule_repr
p84
sg7
L5L
sasg4
I01
sg5
V__loader__
p85
sg7
L3L
sg18
VMeta path import for built-in modules.\u000a\u000a    All methods are either class or static methods to avoid the need to\u000a    instantiate the class.\u000a\u000a    
p86
sa(dp87
g4
I01
sg5
V__name__
p88
sg7
L5L
sa(dp89
g4
I01
sg5
V__package__
p90
sg7
L5L
sa(dp91
g4
I01
sg5
V__spec__
p92
sg7
L5L
sa(dp93
g4
I01
sg5
V_heapify_max
p94
sg7
L2L
sg18
VMaxheap variant of heapify.
p95
sa(dp96
g4
I01
sg5
V_heappop_max
p97
sg7
L2L
sg18
VMaxheap variant of heappop.
p98
sa(dp99
g4
I01
sg5
V_heapreplace_max
p100
sg7
L2L
sg18
VMaxheap variant of heapreplace
p101
sa(dp102
g4
I01
sg5
Vheapify
p103
sg7
L2L
sg18
VTransform list into a heap, in-place, in O(len(heap)) time.
p104
sa(dp105
g4
I01
sg5
Vheappop
p106
sg7
L2L
sg18
VPop the smallest item off the heap, maintaining the heap invariant.
p107
sa(dp108
g4
I01
sg5
Vheappush
p109
sg7
L2L
sg18
Vheappush(heap, item) -> None. Push item onto heap, maintaining the heap invariant.
p110
sa(dp111
g4
I01
sg5
Vheappushpop
p112
sg7
L2L
sg18
Vheappushpop(heap, item) -> value. Push item on the heap, then pop and return the smallest item\u000afrom the heap. The combined action runs more efficiently than\u000aheappush() followed by a separate call to heappop().
p113
sa(dp114
g4
I01
sg5
Vheapreplace
p115
sg7
L2L
sg18
Vheapreplace(heap, item) -> value. Pop and return the current smallest value, and add the new item.\u000a\u000aThis is more efficient than heappop() followed by heappush(), and can be\u000amore appropriate when using a fixed-size heap.  Note that the value\u000areturned may be larger than item!  That constrains reasonable uses of\u000athis routine unless written as part of a conditional replacement:\u000a\u000a    if item > heap[0]:\u000a        item = heapreplace(heap, item)\u000a
p116
sasg4
I01
sg5
V_heapq
p117
sg18
VHeap queue algorithm (a.k.a. priority queue).\u000a\u000aHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\u000aall k, counting elements from 0.  For the sake of comparison,\u000anon-existing elements are considered to be infinite.  The interesting\u000aproperty of a heap is that a[0] is always its smallest element.\u000a\u000aUsage:\u000a\u000aheap = []            # creates an empty heap\u000aheappush(heap, item) # pushes a new item on the heap\u000aitem = heappop(heap) # pops the smallest item from the heap\u000aitem = heap[0]       # smallest item on the heap without popping it\u000aheapify(x)           # transforms list into a heap, in-place, in linear time\u000aitem = heapreplace(heap, item) # pops and returns smallest item, and adds\u000a                               # new item; the heap size is unchanged\u000a\u000aOur API differs from textbook heap algorithms as follows:\u000a\u000a- We use 0-based indexing.  This makes the relationship between the\u000a  index for a node and the indexes for its children slightly less\u000a  obvious, but is more suitable since Python uses 0-based indexing.\u000a\u000a- Our heappop() method returns the smallest item, not the largest.\u000a\u000aThese two make it possible to view the heap as a regular Python list\u000awithout surprises: heap[0] is the smallest item, and heap.sort()\u000amaintains the heap invariant!\u000a
p118
s.